\documentclass[12pt,a4paper]{article}

% Pacotes para o português.
\usepackage[brazilian,provide=*]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{indentfirst}
\usepackage{url}
\usepackage{array}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{setspace}
\usepackage{breakcites}
\usepackage{float}
\usepackage{times}
\usepackage{lipsum}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{amsmath}
\usetikzlibrary{shapes.multipart, arrows.meta, positioning, fit}

\usepackage{sectsty}
\usepackage[compact]{titlesec}

\sectionfont{\normalfont\normalsize\bfseries}
\subsectionfont{\normalfont\normalsize\bfseries}
\subsubsectionfont{\normalfont\normalsize\bfseries}

\newcommand{\nt}[1]{\ensuremath{\langle\text{#1}\rangle}}
\newcommand{\tm}[1]{\ensuremath{\texttt{#1}}}

% Comando para marcar o texto para revisão.
\newcommand{\rev}[1]{\textcolor{red}{#1}}

% Permite escrever aspas normais "text" em vez de ``text''
\usepackage[autostyle]{csquotes}
\MakeOuterQuote{"}

\begin{document}

\begin{titlepage}
	\begin{center}
	
	\vspace{115pt}
 \textbf{\Huge{Manual do Usuário - Simple C}}\\
  
	\vspace{115pt}
 Felipe Gomes da Silva \\
 Luis Henrique Salomão Lobato \\
	\end{center}
	
	\vspace{1cm}
	\begin{center}
		\vspace{\fill}
 \large{Setembro, 2025} 
	\end{center}
\end{titlepage}

% Table of contents

\tableofcontents
\newpage
\section{Introdução}
\label{sec:intd}

Este manual do usuário fornece uma visão geral do Simple C, uma linguagem de programação que visa simplicar o uso de conceitos fundamentais da linguagem C. O Simple C é projetado para ser fácil de aprender e usar, tornando-o ideal para iniciantes em programação, mas removendo algumas funcionalidades avançadas da linguagem C. 

Neste momento, abordaremos apenas o analisador léxico da linguagem. Utilizamos a ferramenta Flex para construir o analisador léxico, que é responsável por identificar e classificar os tokens na entrada do código-fonte.

\section{Testando o Analisador Léxico}
\label{sec:test}

Para testar o analisador léxico do Simple C, siga os passos abaixo:
\begin{enumerate}
  \item Certifique-se de ter o Flex instalado em seu sistema. Você pode verificar isso executando o comando \texttt{flex --version} no terminal.
  \item Clone o repositório do Simple C do GitHub:
 \begin{verbatim}
git clone github.com/felipe-gsilva/simple-c
 \end{verbatim}
  \item Navegue até o diretório do projeto:
 \begin{verbatim}
   cd simple-c/
 \end{verbatim}
  \item Gere o analisador léxico usando o Flex e o compile com nosso script de build
 \begin{verbatim}
   chmod +x build.sh
  ./build.sh
 \end{verbatim}
  \item Execute o analisador léxico com um arquivo de entrada que contenha código Simple C:
 \begin{verbatim}
   ./build/simplec < input_file.c
 \end{verbatim}
 Substitua \texttt{input\_file.c} pelo caminho do arquivo que você deseja analisar.

\item Teste os analisadores com:
  \begin{verbatim}
    chmod +x test.sh
    ./test.sh
  \end{verbatim}

\end{enumerate}


Foram criados alguns arquivos de teste na pasta \texttt{tests} do repositório. Você pode usar esses arquivos para verificar o funcionamento do analisador léxico. Cada arquivo de teste contém exemplos de código Simple C que abrangem diferentes aspectos da linguagem, como declarações de variáveis, estruturas de controle, funções, entre outros. 

Tenha em vista que o analisador sintático ainda não foi implementado, portanto, mudanças na gramática podem ocorrer futuramente.

\section{Tokens Reconhecidos}
\label{sec:token}

O analisador léxico da linguagem Simple C toma a decisão de aceitar ou não determinada sentença com base nos tokens destacados na Tabela \ref{tab:tokens}

\begin{longtable}{lll}
\caption{Tabela de Tokens do Simple C}
\label{tab:tokens} \\

\toprule
\textbf{Nome do Token} & \textbf{Lexema(s)} & \textbf{Descrição} \\
\midrule
\endfirsthead

\toprule
\multicolumn{3}{l}{\small\textit{Tabela \ref{tab:tokens}: Tabela de Tokens do Simple C (Continuação)}} \\
\textbf{Nome do Token} & \textbf{Lexema(s)} & \textbf{Descrição} \\
\midrule
\endhead

\bottomrule
\endlastfoot

\multicolumn{3}{l}{\textbf{Palavras-chave: Tipos de Dados}} \\
\midrule
KEYWORD\_INT & \texttt{int} & Palavra-chave para tipo inteiro. \\
KEYWORD\_FLOAT & \texttt{float} & Palavra-chave para tipo ponto flutuante. \\
KEYWORD\_CHAR & \texttt{char} & Palavra-chave para tipo caractere. \\
KEYWORD\_STRING & \texttt{string} & Palavra-chave para tipo string (cadeia de caracteres). \\
KEYWORD\_VOID & \texttt{void} & Palavra-chave para tipo vazio/nulo. \\
KEYWORD\_BOOL & \texttt{bool} & Palavra-chave para tipo booleano. \\
\midrule
\multicolumn{3}{l}{\textbf{Palavras-chave: Controle de Fluxo e Comandos}} \\
\midrule
KEYWORD\_IF & \texttt{if} & Inicia uma estrutura condicional. \\
KEYWORD\_ELSE & \texttt{else} & Bloco alternativo de uma estrutura condicional. \\
KEYWORD\_FOR & \texttt{for} & Inicia um laço de repetição `for`. \\
KEYWORD\_WHILE & \texttt{while} & Inicia um laço de repetição `while`. \\
KEYWORD\_DO & \texttt{do} & Inicia um laço de repetição `do-while`. \\
KEYWORD\_SWITCH & \texttt{switch} & Inicia uma estrutura de seleção múltipla. \\
KEYWORD\_CASE & \texttt{case} & Define um rótulo dentro de um `switch`. \\
KEYWORD\_DEFAULT & \texttt{default} & Define o rótulo padrão de um `switch`. \\
KEYWORD\_BREAK & \texttt{break} & Interrompe a execução de um laço ou `switch`. \\
KEYWORD\_CONTINUE & \texttt{continue} & Pula para a próxima iteração de um laço. \\
KEYWORD\_RETURN & \texttt{return} & Retorna um valor de uma função. \\
\midrule
\multicolumn{3}{l}{\textbf{Identificadores e Literais}} \\
\midrule
IDENTIFICADOR & \texttt{var}, \texttt{\_x}, ... & Nome de variável, função, etc. \\
INT & \texttt{123}, \texttt{42} & Valor literal inteiro. \\
FLOAT & \texttt{3.14}, \texttt{0.5} & Valor literal de ponto flutuante. \\
CHAR & \texttt{'a'}, \texttt{'\textbackslash n'} & Valor literal de caractere. \\
STRING & \texttt{"hello"} & Valor literal de string. \\
BOOLEAN\_LITERAL & \texttt{true}, \texttt{false} & Valor literal booleano. \\
\midrule
\multicolumn{3}{l}{\textbf{Operadores}} \\
\midrule
OP\_SOMA & \texttt{+} & Operador de adição. \\
OP\_SUB & \texttt{-} & Operador de subtração. \\
OP\_MULT & \texttt{*} & Operador de multiplicação. \\
OP\_DIV & \texttt{/} & Operador de divisão. \\
OP\_MOD & \texttt{\%} & Operador de módulo (resto da divisão). \\
OP\_ATRIBUICAO & \texttt{=} & Operador de atribuição simples. \\
OP\_INC\_ATRIBUICAO & \texttt{+=} & Operador de atribuição com adição. \\
OP\_DEC\_ATRIBUICAO & \texttt{-=} & Operador de atribuição com subtração. \\
OP\_MULT\_ATRIBUICAO & \texttt{*=} & Operador de atribuição com multiplicação. \\
OP\_DIV\_ATRIBUICAO & \texttt{/=} & Operador de atribuição com divisão. \\
OP\_INC & \texttt{++} & Operador de incremento. \\
OP\_DEC & \texttt{--} & Operador de decremento. \\
OP\_IGUAL & \texttt{==} & Operador relacional de igualdade. \\
OP\_DIFERENTE & \texttt{!=} & Operador relacional de desigualdade. \\
OP\_MENOR & \texttt{<} & Operador relacional menor que. \\
OP\_MAIOR & \texttt{>} & Operador relacional maior que. \\
OP\_MENOR\_IGUAL & \texttt{<=} & Operador relacional menor ou igual que. \\
OP\_MAIOR\_IGUAL & \texttt{>=} & Operador relacional maior ou igual que. \\
OP\_AND & \texttt{\&\&} & Operador lógico E (AND). \\
OP\_OR & \texttt{||} & Operador lógico OU (OR). \\
OP\_NOT & \texttt{!} & Operador lógico de negação (NOT). \\
\midrule
\multicolumn{3}{l}{\textbf{Pontuadores e Delimitadores}} \\
\midrule
PONTO\_VIRGULA & \texttt{;} & Finalizador de instrução. \\
DOIS\_PONTOS & \texttt{:} & Usado em casos de `switch`. \\
VIRGULA & \texttt{,} & Separador de elementos (ex: em listas). \\
ABRE\_PARENTESES & \texttt{(} & Abre lista de parâmetros ou expressão. \\
FECHA\_PARENTESES & \texttt{)} & Fecha lista de parâmetros ou expressão. \\
ABRE\_CHAVES & \texttt{\{} & Abre um bloco de código. \\
FECHA\_CHAVES & \texttt{\}} & Fecha um bloco de código. \\
ABRE\_COLCHETES & \texttt{[} & Abre a declaração/acesso de um array. \\
FECHA\_COLCHETES & \texttt{]} & Fecha a declaração/acesso de um array. \\
\end{longtable}


\section{Análise de Erros}
\label{sec:err}

A função \texttt{print\_error} exibe as mensagens de erro léxico e inclui a linha, coluna e token que causaram o erro. Para isto, utilizamos rastreamento de posição durante toda a leitura do código-fonte.

\subsection{Rastreamento de Posição}

Para tratar os erros léxicos de forma eficiente, o analisador léxico do Simple C implementa um mecanismo de rastreamento de posição. Para isto, são declaradas 2 variáveis globais, \texttt{current\_line} e \texttt{current\_col}, que armazenam a linha e a coluna atuais do analisador léxico, respectivamente. Essas variáveis são atualizadas conforme o analisador lê o código-fonte, permitindo que mensagens de erro incluam informações precisas sobre a localização do erro.

\section{Gerenciamento de Estados}
\label{sec:estados}
Para melhor gerenciar o estado do analisador léxico, utilizamos a funcionalidade de estados do Flex. Em especial, foram criados 2 estados diferentes: \texttt{IN\_COMMENT} e \texttt{IN\_STRING}. 

\subsection{Comentários}
Os comentários podem aparecer de 2 formas no código: (i) comentários de linha única, que começam com \texttt{//} e se estendem até o final da linha; (ii) comentários de bloco, que começam com \texttt{/*} e terminam com \texttt{*/}.

\subsection{Strings}

As strings são sequências de caracteres delimitadas por aspas duplas (\texttt{\"}). O analisador léxico reconhece strings e trata caracteres de escape, como \texttt{\textbackslash n} para nova linha e \texttt{\textbackslash t} para tabulação.

Para isso, foi-se utilizado a função \texttt{yymore()} do Flex, que permite concatenar a string lida em \texttt{yytext} com a próxima parte da string lida, até que o caractere de fechamento (\texttt{\"}) seja encontrado.


\section{Gramática da Linguagem Simple-C}
\label{sec:gram}
A partir da definição dos tokens na Seção \ref{sec:token} com a Tabela \ref{tab:tokens}, a linguagem Simple-C pode ser gerada pela gramática livre de contexto definida pela tupla na Equação \ref{eq:gram}. 

Neste contexto, $\Sigma$ é o conjunto de variáveis não terminais (alfabeto), $P$ é o conjunto de regras de produção, $S$ é o símbolo inicial da derivação e $A$ é o conjunto de variáveis não terminais.
\begin{equation}
    \label{eq:gram}
    \boldsymbol{G = (\Sigma, P, S, A)}
\end{equation}

\begin{description}
  \item[Conjunto de Símbolos Terminais ($\Sigma$)] 
    Este é o conjunto de símbolos terminais (tokens) que formam as sentenças da linguagem.
    \[
    \Sigma = \left\{
        \begin{alignedat}{3}
        & \tm{IDENTIFICADOR}, && \tm{PONTO\_VIRGULA}, && \tm{OP\_ATRIBUICAO}, \\
        & \tm{OP\_SOMA}, && \tm{OP\_SUB}, && \tm{OP\_MULT}, \\
        & \tm{OP\_DIV}, && \tm{OP\_INC}, && \tm{OP\_DEC}, \\
        & \tm{KEYWORD\_INT}, && \tm{KEYWORD\_FLOAT}, && \tm{KEYWORD\_STRING}, \\
        & \tm{KEYWORD\_BOOL}, && \tm{INT}, && \tm{FLOAT}, \\
        & \tm{STRING}, && \tm{CHAR}, && \tm{BOOLEAN\_LITERAL}, \\
        & \tm{ABRE\_PARENTESES}, && \tm{FECHA\_PARENTESES}, && \tm{ABRE\_CHAVES}, \\
        & \tm{FECHA\_CHAVES}, && \tm{KEYWORD\_IF}, && \tm{KEYWORD\_ELSE}, \\
        & \tm{KEYWORD\_FOR}, && \tm{KEYWORD\_WHILE}, && \tm{KEYWORD\_DO}, \\
        & \tm{OP\_IGUAL}, && \tm{OP\_DIFERENTE}, && \tm{OP\_MENOR}, \\
        & \tm{OP\_MAIOR}, && \tm{OP\_MENOR\_IGUAL}, && \tm{OP\_MAIOR\_IGUAL}, \\
        & \epsilon
        \end{alignedat}
    \right\}
    \]

    \item[Conjunto de Regras de Produção ($P$)]: 
    O conjunto das regras de produção é definido por:

    \item[\nt{Programa}] $\rightarrow$ \nt{ListaDeComandos}
    \item[\nt{ListaDeComandos}] $\rightarrow$ \nt{Comando} $\mid$ \nt{Comando} \nt{ListaDeComandos}
    \item[\nt{Comando}] $\rightarrow$ \nt{Declaracao} $\mid$ \nt{Atribuicao} $\mid$ \nt{EstruturaDeControle} $\mid$ \nt{ChamadaDeFuncao} $\mid$ \nt{Bloco}
    \item[\nt{Declaracao}] $\rightarrow$ \nt{Tipo} IDENTIFICADOR \nt{AtribuicaoOpcional} PONTO\_VIRGULA
    \item[\nt{Atribuicao}] $\rightarrow$ IDENTIFICADOR OP\_ATRIBUICAO \nt{Expressao} PONTO\_VIRGULA
    \item[\nt{AtribuicaoOpcional}] $\rightarrow$ OP\_ATRIBUICAO \nt{Expressao} $\mid$ $\epsilon$
    \item[\nt{Tipo}] $\rightarrow$ KEYWORD\_INT $\mid$ KEYWORD\_FLOAT $\mid$ KEYWORD\_STRING $\mid$ KEYWORD\_BOOL
    \item[\nt{Literais}] $\rightarrow$ INT $\mid$ FLOAT $\mid$ STRING $\mid$ CHAR $\mid$ BOOLEAN\_LITERAL
    \item[\nt{Expressao}] $\rightarrow$ \nt{Termo} $\mid$ \nt{Expressao} OP\_SOMA \nt{Termo} $\mid$ \nt{Expressao} OP\_SUB \nt{Termo}
    \item[\nt{Termo}] $\rightarrow$ \nt{Fator} $\mid$ \nt{Termo} OP\_MULT \nt{Fator} $\mid$ \nt{Termo} OP\_DIV \nt{Fator}
    \item[\nt{Fator}] $\rightarrow$ IDENTIFICADOR $\mid$ \nt{Literais} $\mid$ ABRE\_PARENTESES \nt{Expressao} FECHA\_PARENTESES $\mid$ OP\_INC $\mid$ OP\_DEC
    \item[\nt{EstruturaDeControle}] $\rightarrow$ \nt{If} $\mid$ \nt{For} $\mid$ \nt{While}
    \item[\nt{If}] $\rightarrow$ KEYWORD\_IF ABRE\_PARENTESES \nt{Condicao} FECHA\_PARENTESES \nt{Comando} \nt{ElseOpcional}
    \item[\nt{ElseOpcional}] $\rightarrow$ KEYWORD\_ELSE \nt{Comando} $\mid$ $\epsilon$
    \item[\nt{Condicao}] $\rightarrow$ \nt{Expressao} \nt{OperadorRelacional} \nt{Expressao}
    \item[\nt{OperadorRelacional}] $\rightarrow$ OP\_IGUAL $\mid$ OP\_DIFERENTE $\mid$ OP\_MENOR $\mid$ OP\_MAIOR $\mid$ OP\_MENOR\_IGUAL $\mid$ OP\_MAIOR\_IGUAL
    \item[\nt{Bloco}] $\rightarrow$ ABRE\_CHAVES \nt{ListaDeComandos} FECHA\_CHAVES

    \item[Conjunto de Não-Terminais ($A$)] 
    O conjunto de símbolos não-terminais é definido por:
    \[
    A = \left\{
        \begin{alignedat}{3}
        & \nt{Programa}, && \nt{ListaDeComandos}, && \nt{Comando}, \\
        & \nt{Declaracao}, && \nt{Atribuicao}, && \nt{AtribuicaoOpcional}, \\
        & \nt{Tipo}, && \nt{Literais}, && \nt{Expressao}, \\
        & \nt{Termo}, && \nt{Fator}, && \nt{EstruturaDeControle}, \\
        & \nt{If}, && \nt{ElseOpcional}, && \nt{Condicao}, \\
        & \nt{OperadorRelacional}, \quad && \nt{Bloco}, && \nt{ChamadaDeFuncao}, \\
        & \nt{For}, && \nt{While}, && \nt{DoWhile}
        \end{alignedat}
    \right\}
    \]

    \item[Símbolo Inicial ($S$)] 
    O símbolo inicial da gramática é:
    \[
    S = \nt{Programa}
    \]
\end{description}


\end{document}

