\documentclass[12pt,a4paper]{article}


% Pacotes para o português.
\usepackage[brazilian,provide=*]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{indentfirst}
\usepackage{url}
\usepackage{array}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{setspace}
\usepackage{breakcites}
\usepackage{float}
\usepackage{times}
\usepackage{lipsum}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{listings}
\usetikzlibrary{shapes.multipart, arrows.meta, positioning, fit}

\usepackage{sectsty}
\usepackage[compact]{titlesec}

\sectionfont{\normalfont\normalsize\bfseries}
\subsectionfont{\normalfont\normalsize\bfseries}
\subsubsectionfont{\normalfont\normalsize\bfseries}

\newcommand{\nt}[1]{\ensuremath{\langle\text{#1}\rangle}}
\newcommand{\tm}[1]{\ensuremath{\texttt{#1}}}

% Comando para marcar o texto para revisão.
\newcommand{\rev}[1]{\textcolor{red}{#1}}

% Permite escrever aspas normais "text" em vez de ``text''
\usepackage[autostyle]{csquotes}
\MakeOuterQuote{"}
\definecolor{darkcyan}{rgb}{0.0, 0.5, 0.5} % Define uma cor para os tipos
\lstdefinestyle{simpleCStyle}{
    language=C, % Usa as configurações básicas de C
    basicstyle=\ttfamily\small, % Fonte monoespaçada e pequena
    keywordstyle=\color{blue}\bfseries, % Palavras-chave de controle (if, for, return, etc) em azul
    identifierstyle=\color{black}, % Identificadores em preto
    commentstyle=\color{green!60!black}, % Comentários em verde escuro
    stringstyle=\color{red!80!black}, % Strings em vermelho
    showstringspaces=false,
    numbers=left, % Números de linha à esquerda
    numberstyle=\tiny\color{gray}, % Tamanho e cor dos números de linha
    frame=single, % Desenha uma moldura simples ao redor do código
    frameround=tttt, % Cantos arredondados (opcional)
    breaklines=true, % Quebra de linha automática
    captionpos=b, % Posição da legenda abaixo do bloco
    tabsize=4,
    extendedchars=true,
    % NOVO: Define um segundo conjunto de palavras-chave (keyworset 2) para os tipos de dados
    morekeywords=[2]{int, float, char, string, void, bool},
    % NOVO: Aplica uma cor diferente ao keyworset 2
    keywordstyle={[2]\color{darkcyan}\bfseries},
    literate={-}{-}1 % Corrige o problema com o operador de subtração/sinal de negativo
}
\renewcommand{\lstlistingname}{Código}
% Aplica o estilo definido
\lstset{style=simpleCStyle}
% --- Fim do Estilo ---
\begin{document}

\begin{titlepage}
	\begin{center}
	
	\vspace{115pt}
 \textbf{\Huge{Manual do Usuário - Simple C}}\\
  
	\vspace{115pt}
 Felipe Gomes da Silva \\
 Luis Henrique Salomão Lobato \\
	\end{center}
	
	\vspace{1cm}
	\begin{center}
		\vspace{\fill}
 \large{Setembro, 2025} 
	\end{center}
\end{titlepage}

% Table of contents

\tableofcontents
\newpage
\section{Introdução}
\label{sec:intd}

Este manual do usuário fornece uma visão geral do Simple C, uma linguagem de programação que visa simplicar o uso de conceitos fundamentais da linguagem C. O Simple C é projetado para ser fácil de aprender e usar, tornando-o ideal para iniciantes em programação, mas removendo algumas funcionalidades avançadas da linguagem C. 

Neste momento, abordaremos apenas o analisador léxico da linguagem. Utilizamos a ferramenta Flex para construir o analisador léxico, que é responsável por identificar e classificar os tokens na entrada do código-fonte.

\section{Testando o Analisador Léxico}
\label{sec:test}

Para testar o analisador léxico do Simple C, siga os passos abaixo:
\begin{enumerate}
  \item Certifique-se de ter o Flex instalado em seu sistema. Você pode verificar isso executando o comando \texttt{flex --version} no terminal.
  \item Clone o repositório do Simple C do GitHub:
 \begin{verbatim}
git clone github.com/felipe-gsilva/simple-c
 \end{verbatim}
  \item Navegue até o diretório do projeto:
 \begin{verbatim}
   cd simple-c/
 \end{verbatim}
  \item Gere o analisador léxico usando o Flex e o compile com nosso script de build
 \begin{verbatim}
   chmod +x build.sh
  ./build.sh
 \end{verbatim}
  \item Execute o analisador léxico com um arquivo de entrada que contenha código Simple C:
 \begin{verbatim}
   ./build/simplec < input_file.c
 \end{verbatim}
 Substitua \texttt{input\_file.c} pelo caminho do arquivo que você deseja analisar.

\item Teste os analisadores com:
  \begin{verbatim}
    chmod +x test.sh
    ./test.sh
  \end{verbatim}

\end{enumerate}


Foram criados alguns arquivos de teste na pasta \texttt{tests} do repositório. Você pode usar esses arquivos para verificar o funcionamento do analisador léxico. Cada arquivo de teste contém exemplos de código Simple C que abrangem diferentes aspectos da linguagem, como declarações de variáveis, estruturas de controle, funções, entre outros. 

Tenha em vista que o analisador sintático ainda não foi implementado, portanto, mudanças na gramática podem ocorrer futuramente.

\section{Tokens Reconhecidos}
\label{sec:token}

O analisador léxico da linguagem Simple C toma a decisão de aceitar ou não determinada sentença com base nos tokens destacados na Tabela \ref{tab:tokens}

\begin{longtable}{lll}
\caption{Tabela de Tokens do Simple C}
\label{tab:tokens} \\

\toprule
\textbf{Nome do Token} & \textbf{Lexema(s)} & \textbf{Descrição} \\
\midrule
\endfirsthead

\toprule
\multicolumn{3}{l}{\small\textit{Tabela \ref{tab:tokens}: Tabela de Tokens do Simple C (Continuação)}} \\
\textbf{Nome do Token} & \textbf{Lexema(s)} & \textbf{Descrição} \\
\midrule
\endhead

\bottomrule
\endlastfoot

\multicolumn{3}{l}{\textbf{Palavras-chave: Tipos de Dados}} \\
\midrule
KEYWORD\_INT & \texttt{int} & Palavra-chave para tipo inteiro. \\
KEYWORD\_FLOAT & \texttt{float} & Palavra-chave para tipo ponto flutuante. \\
KEYWORD\_CHAR & \texttt{char} & Palavra-chave para tipo caractere. \\
KEYWORD\_STRING & \texttt{string} & Palavra-chave para tipo string (cadeia de caracteres). \\
KEYWORD\_VOID & \texttt{void} & Palavra-chave para tipo vazio/nulo. \\
KEYWORD\_BOOL & \texttt{bool} & Palavra-chave para tipo booleano. \\
\midrule
\multicolumn{3}{l}{\textbf{Palavras-chave: Controle de Fluxo e Comandos}} \\
\midrule
KEYWORD\_IF & \texttt{if} & Inicia uma estrutura condicional. \\
KEYWORD\_ELSE & \texttt{else} & Bloco alternativo de uma estrutura condicional. \\
KEYWORD\_FOR & \texttt{for} & Inicia um laço de repetição `for`. \\
KEYWORD\_WHILE & \texttt{while} & Inicia um laço de repetição `while`. \\
KEYWORD\_DO & \texttt{do} & Inicia um laço de repetição `do-while`. \\
KEYWORD\_SWITCH & \texttt{switch} & Inicia uma estrutura de seleção múltipla. \\
KEYWORD\_CASE & \texttt{case} & Define um rótulo dentro de um `switch`. \\
KEYWORD\_DEFAULT & \texttt{default} & Define o rótulo padrão de um `switch`. \\
KEYWORD\_BREAK & \texttt{break} & Interrompe a execução de um laço ou `switch`. \\
KEYWORD\_CONTINUE & \texttt{continue} & Pula para a próxima iteração de um laço. \\
KEYWORD\_RETURN & \texttt{return} & Retorna um valor de uma função. \\
\midrule
\multicolumn{3}{l}{\textbf{Identificadores e Literais}} \\
\midrule
IDENTIFICADOR & \texttt{var}, \texttt{\_x}, ... & Nome de variável, função, etc. \\
INT & \texttt{123}, \texttt{42} & Valor literal inteiro. \\
FLOAT & \texttt{3.14}, \texttt{0.5} & Valor literal de ponto flutuante. \\
CHAR & \texttt{'a'}, \texttt{'\textbackslash n'} & Valor literal de caractere. \\
STRING & \texttt{"hello"} & Valor literal de string. \\
BOOLEAN\_LITERAL & \texttt{true}, \texttt{false} & Valor literal booleano. \\
\midrule
\multicolumn{3}{l}{\textbf{Operadores}} \\
\midrule
OP\_SOMA & \texttt{+} & Operador de adição. \\
OP\_SUB & \texttt{-} & Operador de subtração. \\
OP\_MULT & \texttt{*} & Operador de multiplicação. \\
OP\_DIV & \texttt{/} & Operador de divisão. \\
OP\_MOD & \texttt{\%} & Operador de módulo (resto da divisão). \\
OP\_ATRIBUICAO & \texttt{=} & Operador de atribuição simples. \\
OP\_INC\_ATRIBUICAO & \texttt{+=} & Operador de atribuição com adição. \\
OP\_DEC\_ATRIBUICAO & \texttt{-=} & Operador de atribuição com subtração. \\
OP\_MULT\_ATRIBUICAO & \texttt{*=} & Operador de atribuição com multiplicação. \\
OP\_DIV\_ATRIBUICAO & \texttt{/=} & Operador de atribuição com divisão. \\
OP\_INC & \texttt{++} & Operador de incremento. \\
OP\_DEC & \texttt{--} & Operador de decremento. \\
OP\_IGUAL & \texttt{==} & Operador relacional de igualdade. \\
OP\_DIFERENTE & \texttt{!=} & Operador relacional de desigualdade. \\
OP\_MENOR & \texttt{<} & Operador relacional menor que. \\
OP\_MAIOR & \texttt{>} & Operador relacional maior que. \\
OP\_MENOR\_IGUAL & \texttt{<=} & Operador relacional menor ou igual que. \\
OP\_MAIOR\_IGUAL & \texttt{>=} & Operador relacional maior ou igual que. \\
OP\_AND & \texttt{\&\&} & Operador lógico E (AND). \\
OP\_OR & \texttt{||} & Operador lógico OU (OR). \\
OP\_NOT & \texttt{!} & Operador lógico de negação (NOT). \\
\midrule
\multicolumn{3}{l}{\textbf{Pontuadores e Delimitadores}} \\
\midrule
PONTO\_VIRGULA & \texttt{;} & Finalizador de instrução. \\
DOIS\_PONTOS & \texttt{:} & Usado em casos de `switch`. \\
VIRGULA & \texttt{,} & Separador de elementos (ex: em listas). \\
ABRE\_PARENTESES & \texttt{(} & Abre lista de parâmetros ou expressão. \\
FECHA\_PARENTESES & \texttt{)} & Fecha lista de parâmetros ou expressão. \\
ABRE\_CHAVES & \texttt{\{} & Abre um bloco de código. \\
FECHA\_CHAVES & \texttt{\}} & Fecha um bloco de código. \\
ABRE\_COLCHETES & \texttt{[} & Abre a declaração/acesso de um array. \\
FECHA\_COLCHETES & \texttt{]} & Fecha a declaração/acesso de um array. \\
\end{longtable}


\section{Análise de Erros}
\label{sec:err}

O Simple C implementa um tratamento de erros em duas fases: léxica (Flex) e sintática (Bison).

\subsection{Tratamento de Erros Léxicos (Flex)}
O analisador léxico é configurado para detectar e reportar falhas específicas, além de caracteres desconhecidos, garantindo um diagnóstico preciso no código-fonte. Para isto, são utilizadas as variáveis globais \texttt{current\_line} e \texttt{current\_col}, que rastreiam a posição exata de cada token reconhecido.

A função de erro léxico, \texttt{print\_error}, reporta a linha, coluna, o tipo de erro e o texto problemático (\texttt{yytext}). Erros capturados incluem:
\begin{itemize}
    \item Identificadores que iniciam com dígitos.
    \item Literais de caracteres contendo múltiplos caracteres.
    \item Construtos não fechados, como comentários de bloco (\texttt{/*}) ou strings (\texttt{"\dots"}) no fim do arquivo ou com quebras de linha inesperadas.
\end{itemize}

\subsection{Tratamento de Erros Sintáticos (Bison)}

A detecção de erros sintáticos é responsabilidade do Analisador Sintático (Bison). Um erro ocorre quando a sequência de tokens fornecida pelo Flex não pode ser reduzida a nenhuma regra de produção da Gramática Livre de Contexto ($G$).

\subsubsection{Função de Erro Sintático e Rastreamento}
Quando um erro de sintaxe é encontrado, o Bison invoca a função $\texttt{yyerror(\dots)}$. Esta função aproveita as variáveis globais $\texttt{current\_line}$ e $\texttt{current\_col}$ (mantidas pelo Flex) para informar ao usuário a linha e coluna exatas onde a violação sintática foi detectada.

A função de erro, definida no arquivo Bison, é:
\begin{lstlisting}[caption={Função para tratamento de erros}]
    void yyerror(const char *s) {
        fprintf(stderr,
        "Erro Sintatico na Linha %d, Coluna %d: %s\n",
        current_line,
        current_col,
        s
        );
        exit(1);
    }
\end{lstlisting}


\subsubsection{Precedência e Associatividade}
A ambiguidade sintática, especialmente em expressões complexas, é resolvida pela definição explícita de Precedência e Associatividade dos operadores no arquivo Bison (usando diretivas como `left`, `right`). Isto garante que a estrutura sintática preferida siga a ordem de avaliação matemática e lógica esperada (ex: multiplicação antes da soma).
\section{Gerenciamento de Estados}
\label{sec:estados}
Para melhor gerenciar o estado do analisador léxico, utilizamos a funcionalidade de estados do Flex. Em especial, foram criados 2 estados diferentes: \texttt{IN\_COMMENT} e \texttt{IN\_STRING}. 

\subsection{Comentários}
Os comentários podem aparecer de 2 formas no código: (i) comentários de linha única, que começam com \texttt{//} e se estendem até o final da linha; (ii) comentários de bloco, que começam com \texttt{/*} e terminam com \texttt{*/}.

\subsection{Strings}

As strings são sequências de caracteres delimitadas por aspas duplas (\texttt{\"}). O analisador léxico reconhece strings e trata caracteres de escape, como \texttt{\textbackslash n} para nova linha e \texttt{\textbackslash t} para tabulação.

Para isso, foi-se utilizado a função \texttt{yymore()} do Flex, que permite concatenar a string lida em \texttt{yytext} com a próxima parte da string lida, até que o caractere de fechamento (\texttt{\"}) seja encontrado. 

Com isso, é possível a declaração e atribuição de strings com múltiplas linhas. Segue no Código \ref{lsl:st}, exemplos diversos sobre este tipo de dado.

\begin{lstlisting}[caption={Exemplos para o tratamento de strings.}, label={lsl:st}]
    // Teste de literais de string, incluindo escapes
    string s = "Uma string de teste com \"aspas\" escapadas.";
    string outra_string_123 = "outra string";
    string string_com_3_linhas = 
    """
    Linha 1\nLinha 2\nLinha 3
    """;
\end{lstlisting}

\section{Exemplos de uso}
Nesta seção serão descritos exemplos do código da Linguagem Simple C, visando introduzir conceitos básicos sobre a sintaxe para o uso da mesma. 

\subsection{Declaração de Variáveis e Tipos de Dados}
Abaixo é apresentado um trecho de código de exemplo da linguagem Simple C, que será processado pelo Analisador Léxico (Seção \ref{sec:token}). As cores indicam os tokens reconhecidos, conforme o estilo definido:

\begin{lstlisting}[caption={Exemplo de Código com Tokens da Simple C}, label={lst:codigo_exemplo}]
    int i = 12345;
    int i_2 = -12345;
    float _f = .5; // Ponto flutuante implicito
    float _f2 = 0.555555;
    float _f3 = 1.000000;
    char c = 'A';
    bool flag = true;
    char newline = '\n'; // Teste de escape em char
    int resultado_final = 0;
\end{lstlisting}

\subsection{Estruturas Condicionais e de Controle}
Seguem exemplos para estruturas condicionais e de controle. No Código \ref{lsl:if}, apresenta-se a utilização de um "If-Else". Já no Código \ref{lst:sw},  está definida a estrutura "Switch-Case".

\begin{lstlisting}[caption={Exemplo de estrutura de Controle If-Else}, label={lsl:if}]

    // Estrutura condicional 'if-else' com operadores logicos 
    //e relacionais
    if (flag == true && (i < 1000 || i >= 2000)) {
        resultado_final = 1;
    } else if (!flag) {
        resultado_final = -1;
    }
\end{lstlisting}

\begin{lstlisting}[caption={Exemplo de estrutura de Controle Switch-Case}, label={lst:sw}]
    switch (c) {
        case 'A':
            i = 1;
            break;
        case 'B':
            i = 2;
            break;
        default:
            i = 0;
    }
\end{lstlisting}

\subsection{Laços de Repetição}
\label{sec:lacos}

A linguagem Simple C suporta três estruturas de repetição fundamentais, que permitem a execução iterativa de blocos de código: o laço \texttt{for}, o laço \texttt{while} e o laço \texttt{do-while}.
O uso dos comandos \texttt{break} e \texttt{continue} (Tokens listados na Tabela \ref{tab:tokens}) é permitido dentro dos corpos de todos os laços para controlar o fluxo de execução.

\subsubsection{Exemplo de Laço \texttt{for}}
O laço \texttt{for} no Simple C segue a estrutura padrão, onde a inicialização, a condição de parada e o passo de iteração são explicitados entre parênteses.

\begin{lstlisting}[caption={"Laço de repetição For Loop"}, label={lsl:fl}]
    for (int j = 0; j != 10; j++) {
        if (j <= 1) {
        continue; // Pula para a proxima iteracao
    }
        if (j > 8) {
            break; // Interrompe o laco
        }
    }
\end{lstlisting}

\subsubsection{Exemplo de Laços \texttt{while} e \texttt{do-while}}
Os laços condicionais \texttt{while} e \texttt{do-while} são implementados com base na avaliação de uma expressão relacional. Note que o \texttt{do-while} garante pelo menos uma execução do bloco.

\begin{lstlisting}[caption={"Laços de Repetição While e Do While"}, label={lsl:wl}]
    int k = 10;
    while(k > 5) {
        k--;
    }
    
    do {
        k++;
    } while (k < 10);
\end{lstlisting}
\end{document}

