\documentclass[12pt,a4paper]{article}


% Pacotes para o português.
\usepackage[brazilian,provide=*]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{indentfirst}
\usepackage{url}
\usepackage{array}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{setspace}
\usepackage{breakcites}
\usepackage{float}
\usepackage{times}
\usepackage{lipsum}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{listings}
\usetikzlibrary{shapes.multipart, arrows.meta, positioning, fit}

\usepackage{sectsty}
\usepackage[compact]{titlesec}

\sectionfont{\normalfont\normalsize\bfseries}
\subsectionfont{\normalfont\normalsize\bfseries}
\subsubsectionfont{\normalfont\normalsize\bfseries}

\newcommand{\nt}[1]{\ensuremath{\langle\text{#1}\rangle}}
\newcommand{\tm}[1]{\ensuremath{\texttt{#1}}}
% REMOVIDO: \newcommand{\epsilonSymbol}{\varepsilon} para usar \varepsilon diretamente no modo matemático.

% Comando para marcar o texto para revisão.
\newcommand{\rev}[1]{\textcolor{red}{#1}}

% Permite escrever aspas normais "text" em vez de ``text''
\usepackage[autostyle]{csquotes}
\MakeOuterQuote{"}
\definecolor{darkcyan}{rgb}{0.0, 0.5, 0.5} % Define uma cor para os tipos
\lstdefinestyle{simpleCStyle}{
	language=C, % Usa as configurações básicas de C
	basicstyle=\ttfamily\small, % Fonte monoespaçada e pequena
	keywordstyle=\color{blue}\bfseries, % Palavras-chave de controle (if, for, return, etc) em azul
	identifierstyle=\color{black}, % Identificadores em preto
	commentstyle=\color{green!60!black}, % Comentários em verde escuro
	stringstyle=\color{red!80!black}, % Strings em vermelho
	showstringspaces=false,
	numbers=left, % Números de linha à esquerda
	numberstyle=\tiny\color{gray}, % Tamanho e cor dos números de linha
	frame=single, % Desenha uma moldura simples ao redor do código
	frameround=tttt, % Cantos arredondados (opcional)
	breaklines=true, % Quebra de linha automática
	captionpos=b, % Posição da legenda abaixo do bloco
	tabsize=4,
	extendedchars=true,
	% NOVO: Define um segundo conjunto de palavras-chave (keyworset 2) para os tipos de dados
	morekeywords=[2]{int, float, char, string, void, bool},
	% NOVO: Aplica uma cor diferente ao keyworset 2
	keywordstyle={[2]\color{darkcyan}\bfseries},
	literate={-}{-}1 % Corrige o problema com o operador de subtração/sinal de negativo
}
\renewcommand{\lstlistingname}{Código}
% Aplica o estilo definido
\lstset{style=simpleCStyle}
% --- Fim do Estilo ---

\let\cleardoublepage\clearpage
\begin{document}
	
	\begin{titlepage}
		\begin{center}
			
			\vspace{115pt}
			\textbf{\Huge{Manual do Usuário - Simple C}}\\
			
			\vspace{115pt}
			Felipe Gomes da Silva \\
			Luis Henrique Salomão Lobato \\
		\end{center}
		
		\vspace{1cm}
		\begin{center}
			\vspace{\fill}
			\large{Setembro, 2025} 
		\end{center}
	\end{titlepage}
	
	% Table of contents
	
	\tableofcontents
	\newpage
	\section{Introdução}
	\label{sec:intd}
	
	Este manual do usuário fornece uma visão geral do Simple C, uma linguagem de programação que visa simplicar o uso de conceitos fundamentais da linguagem C. O Simple C é projetado para ser fácil de aprender e usar, tornando-o ideal para iniciantes em programação, mas removendo algumas funcionalidades avançadas da linguagem C. 
	
	Neste momento, abordaremos apenas o analisador léxico da linguagem. Utilizamos a ferramenta Flex para construir o analisador léxico, que é responsável por identificar e classificar os tokens na entrada do código-fonte.
	
	\section{Testando o Analisador Léxico}
	\label{sec:test}
	
	Para testar o analisador léxico do Simple C, siga os passos abaixo:
	\begin{enumerate}
		\item Certifique-se de ter o Flex instalado em seu sistema. Você pode verificar isso executando o comando \texttt{flex --version} no terminal.
		\item Clone o repositório do Simple C do GitHub:
		\begin{verbatim}
			git clone github.com/felipe-gsilva/simple-c
		\end{verbatim}
		\item Navegue até o diretório do projeto:
		\begin{verbatim}
			cd simple-c/
		\end{verbatim}
		\item Gere o analisador léxico usando o Flex e o compile com nosso script de build
		\begin{verbatim}
			chmod +x build.sh
			./build.sh
		\end{verbatim}
		\item Execute o analisador léxico com um arquivo de entrada que contenha código Simple C:
		\begin{verbatim}
			./build/simplec < input_file.c
		\end{verbatim}
		Substitua \texttt{input\_file.c} pelo caminho do arquivo que você deseja analisar.
		
		\item Teste os analisadores com:
		\begin{verbatim}
			chmod +x test.sh
			./test.sh
		\end{verbatim}
		
	\end{enumerate}
	
	
	Foram criados alguns arquivos de teste na pasta \texttt{tests} do repositório. Você pode usar esses arquivos para verificar o funcionamento do analisador léxico. Cada arquivo de teste contém exemplos de código Simple C que abrangem diferentes aspectos da linguagem, como declarações de variáveis, estruturas de controle, funções, entre outros. 
	
	Tenha em vista que o analisador sintático ainda não foi implementado, portanto, mudanças na gramática podem ocorrer futuramente.
	
	\section{Tokens Reconhecidos}
	\label{sec:token}
	
	O analisador léxico da linguagem Simple C toma a decisão de aceitar ou não determinada sentença com base nos tokens destacados na Tabela \ref{tab:tokens}
	
	\begin{longtable}{lll}
		\caption{Tabela de Tokens do Simple C}
		\label{tab:tokens} \\
		
		\toprule
		\textbf{Nome do Token} & \textbf{Lexema(s)} & \textbf{Descrição} \\
		\midrule
		\endfirsthead
		
		\toprule
		\multicolumn{3}{l}{\small\textit{Tabela \ref{tab:tokens}: Tabela de Tokens do Simple C (Continuação)}} \\
		\textbf{Nome do Token} & \textbf{Lexema(s)} & \textbf{Descrição} \\
		\midrule
		\endhead
		
		\bottomrule
		\endlastfoot
		
		\multicolumn{3}{l}{\textbf{Palavras-chave: Tipos de Dados}} \\
		\midrule
		KEYWORD\_INT & \texttt{int} & Palavra-chave para tipo inteiro. \\
		KEYWORD\_FLOAT & \texttt{float} & Palavra-chave para tipo ponto flutuante. \\
		KEYWORD\_CHAR & \texttt{char} & Palavra-chave para tipo caractere. \\
		KEYWORD\_STRING & \texttt{string} & Palavra-chave para tipo string (cadeia de caracteres). \\
		KEYWORD\_VOID & \texttt{void} & Palavra-chave para tipo vazio/nulo. \\
		KEYWORD\_BOOL & \texttt{bool} & Palavra-chave para tipo booleano. \\
		\midrule
		\multicolumn{3}{l}{\textbf{Palavras-chave: Controle de Fluxo e Comandos}} \\
		\midrule
		KEYWORD\_IF & \texttt{if} & Inicia uma estrutura condicional. \\
		KEYWORD\_ELSE & \texttt{else} & Bloco alternativo de uma estrutura condicional. \\
		KEYWORD\_FOR & \texttt{for} & Inicia um laço de repetição `for`. \\
		KEYWORD\_WHILE & \texttt{while} & Inicia um laço de repetição `while`. \\
		KEYWORD\_DO & \texttt{do} & Inicia um laço de repetição `do-while`. \\
		KEYWORD\_SWITCH & \texttt{switch} & Inicia uma estrutura de seleção múltipla. \\
		KEYWORD\_CASE & \texttt{case} & Define um rótulo dentro de um `switch`. \\
		KEYWORD\_DEFAULT & \texttt{default} & Define o rótulo padrão de um `switch`. \\
		KEYWORD\_BREAK & \texttt{break} & Interrompe a execução de um laço ou `switch`. \\
		KEYWORD\_CONTINUE & \texttt{continue} & Pula para a próxima iteração de um laço. \\
		KEYWORD\_RETURN & \texttt{return} & Retorna um valor de uma função. \\
		\midrule
		\multicolumn{3}{l}{\textbf{Identificadores e Literais}} \\
		\midrule
		IDENTIFICADOR & \texttt{var}, \texttt{\_x}, ... & Nome de variável, função, etc. \\
		INT & \texttt{123}, \texttt{42} & Valor literal inteiro. \\
		FLOAT & \texttt{3.14}, \texttt{0.5} & Valor literal de ponto flutuante. \\
		CHAR & \texttt{'a'}, \texttt{'\textbackslash n'} & Valor literal de caractere. \\
		STRING & \texttt{"hello"} & Valor literal de string. \\
		BOOLEAN\_LITERAL & \texttt{true}, \texttt{false} & Valor literal booleano. \\
		\midrule
		\multicolumn{3}{l}{\textbf{Operadores}} \\
		\midrule
		OP\_SOMA & \texttt{+} & Operador de adição. \\
		OP\_SUB & \texttt{-} & Operador de subtração. \\
		OP\_MULT & \texttt{*} & Operador de multiplicação. \\
		OP\_DIV & \texttt{/} & Operador de divisão. \\
		OP\_MOD & \texttt{\%} & Operador de módulo (resto da divisão). \\
		OP\_ATRIBUICAO & \texttt{=} & Operador de atribuição simples. \\
		OP\_INC\_ATRIBUICAO & \texttt{+=} & Operador de atribuição com adição. \\
		OP\_DEC\_ATRIBUICAO & \texttt{-=} & Operador de atribuição com subtração. \\
		OP\_MULT\_ATRIBUICAO & \texttt{*=} & Operador de atribuição com multiplicação. \\
		OP\_DIV\_ATRIBUICAO & \texttt{/=} & Operador de atribuição com divisão. \\
		OP\_INC & \texttt{++} & Operador de incremento. \\
		OP\_DEC & \texttt{--} & Operador de decremento. \\
		OP\_IGUAL & \texttt{==} & Operador relacional de igualdade. \\
		OP\_DIFERENTE & \texttt{!=} & Operador relacional de desigualdade. \\
		OP\_MENOR & \texttt{<} & Operador relacional menor que. \\
		OP\_MAIOR & \texttt{>} & Operador relacional maior que. \\
		OP\_MENOR\_IGUAL & \texttt{<=} & Operador relacional menor ou igual que. \\
		OP\_MAIOR\_IGUAL & \texttt{>=} & Operador relacional maior ou igual que. \\
		OP\_AND & \texttt{\&\&} & Operador lógico E (AND). \\
		OP\_OR & \texttt{||} & Operador lógico OU (OR). \\
		OP\_NOT & \texttt{!} & Operador lógico de negação (NOT). \\
		\midrule
		\multicolumn{3}{l}{\textbf{Pontuadores e Delimitadores}} \\
		\midrule
		PONTO\_VIRGULA & \texttt{;} & Finalizador de instrução. \\
		DOIS\_PONTOS & \texttt{:} & Usado em casos de `switch`. \\
		VIRGULA & \texttt{,} & Separador de elementos (ex: em listas). \\
		ABRE\_PARENTESES & \texttt{(} & Abre lista de parâmetros ou expressão. \\
		FECHA\_PARENTESES & \texttt{)} & Fecha lista de parâmetros ou expressão. \\
		ABRE\_CHAVES & \texttt{\{} & Abre um bloco de código. \\
		FECHA\_CHAVES & \texttt{\}} & Fecha um bloco de código. \\
		ABRE\_COLCHETES & \texttt{[} & Abre a declaração/acesso de um array. \\
		FECHA\_COLCHETES & \texttt{]} & Fecha a declaração/acesso de um array. \\
	\end{longtable}
	
		\section{Descrição da Liguagem Regular - Analisador Léxico}
	\label{sec:desc}
	
	A linguagem regular estruturada para a aceitação e classificação das cadeias de caracteres, que compõem o código-fonte da linguagem Simple C, é formalmente descrita através do conjunto de expressões regulares detalhadas na Tabela \ref{tab:expressoes}. Esta definição rigorosa não apenas estabelece o vocabulário básico do Simple C (identificadores, literais, operadores e palavras-chave), mas também atua como a primeira linha de defesa contra erros. Através da aplicação precisa dessas regras, é garantido que o processo de reconhecimento de tokens seja robusto e não ambíguo. Por exemplo, o analisador léxico assegura estritamente que variáveis e nomes de funções não possam ser declarados com dígitos como primeiro caractere da cadeia, preservando a sintaxe esperada. Adicionalmente, esta etapa é crucial para a identificação e tratamento de outros erros léxicos críticos, como comentários não fechados ou literais malformados, que, se não detectados, comprometeriam fatalmente as fases subsequentes de análise sintática e semântica.
	\begin{table}[H]
		\centering
		\caption{Expressões regulares do analisador léxico.}
		\label{tab:expressoes}
		\begin{tabular}{l p{5cm} l}
			\toprule
			\textbf{Expressão Regular} & \textbf{Descrição} & \textbf{Tipo} \\
			\midrule
			\texttt{\detokenize{[a-zA-Z_][a-zA-Z0-9_]*}} & Reconhece identificadores válidos que começam com uma letra ou um sublinhado. & Identificador \\
			\addlinespace
			\texttt{\detokenize{0|[+-]?[1-9][0-9]*}} & Reconhece números inteiros. & Literal \\
			\addlinespace
			\texttt{\detokenize{[+-]?([0-9]+\.[0-9]*|\.[0-9]+)}} & Reconhece números de ponto flutuante. & Literal \\
			\midrule
			\texttt{\detokenize{//.*}} & Comentário de linha única, que começa com \texttt{//} e vai até o final da linha. & Comentário \\
			\addlinespace
			\texttt{\detokenize{/*}} & Inicia um comentário de bloco. & Comentário \\
			\addlinespace
			\texttt{\detokenize{<IN_COMMENT>"*/"}} & Fecha um comentário de bloco. & Comentário \\
			\midrule
			\texttt{\detokenize{"(\.|[^"\n])+"}} & Conteúdo de uma string, incluindo caracteres escapados. & String \\
			\addlinespace
			\texttt{\detokenize{'(\.|[^'\\])'}} & Reconhece literais de caracteres. & Caractere \\
			\midrule
			\texttt{\detokenize{==, !=, <=, >=, etc.}} & Operadores de comparação, lógicos e aritméticos. & Operador \\
			\addlinespace
			\texttt{\detokenize{;, <, >, {, }}} & Símbolos de pontuação e agrupamento. & Símbolo \\
			\midrule
			\texttt{\detokenize{{INT}{ID}}} & Captura identificadores que começam com um número, que é um erro léxico. & Erro \\
			\addlinespace
			\texttt{\detokenize{.}} & Captura qualquer caractere que não corresponda a nenhuma regra. & Erro \\
			\texttt{\detokenize{[+-]?0[0-9]+}} & Captura números inteiros com zeros à esquerda, que é um erro léxico. & Erro \\
			\addlinespace
			\bottomrule
		\end{tabular}
	\end{table}
	
	
	
	
	\section{Linguagem Livre de Contexto - Analisador Sintático}
	
	\subsection{Gramática da Linguagem Livre de Contexto}
	\label{sec:gram}
	A partir da definição dos tokens na Seção \ref{sec:token} com a Tabela \ref{tab:tokens}, a linguagem Simple-C pode ser gerada pela gramática livre de contexto definida pela tupla na Equação \ref{eq:gram}. 
	
	Neste contexto, $\Sigma$ é o conjunto de variáveis não terminais (alfabeto), $P$ é o conjunto de regras de produção, $S$ é o símbolo inicial da derivação e $A$ é o conjunto de variáveis não terminais.
	\begin{equation}
		\label{eq:gram}
		\boldsymbol{G = (\Sigma, P, S, A)}
	\end{equation}
	
	\begin{description}
		\item[Conjunto de Símbolos Terminais ($\Sigma$)] 
		Este é o conjunto de símbolos terminais (tokens) que formam as sentenças da linguagem.
		\[
		\Sigma = \left\{
		\begin{alignedat}{3}
			& \tm{IDENTIFICADOR}, && \tm{PONTO\_VIRGULA}, && \tm{OP\_ATRIBUICAO}, \\
			& \tm{OP\_SOMA}, && \tm{OP\_SUB}, && \tm{OP\_MULT}, \\
			& \tm{OP\_DIV}, && \tm{OP\_INC}, && \tm{OP\_DEC}, \\
			& \tm{KEYWORD\_INT}, && \tm{KEYWORD\_FLOAT}, && \tm{KEYWORD\_STRING}, \\
			& \tm{KEYWORD\_BOOL}, && \tm{INT}, && \tm{FLOAT}, \\
			& \tm{STRING}, && \tm{CHAR}, && \tm{BOOLEAN\_LITERAL}, \\
			& \tm{ABRE\_PARENTESES}, && \tm{FECHA\_PARENTESES}, && \tm{ABRE\_CHAVES}, \\
			& \tm{FECHA\_CHAVES}, && \tm{KEYWORD\_IF}, && \tm{KEYWORD\_ELSE}, \\
			& \tm{KEYWORD\_FOR}, && \tm{KEYWORD\_WHILE}, && \tm{KEYWORD\_DO}, \\
			& \tm{OP\_IGUAL}, && \tm{OP\_DIFERENTE}, && \tm{OP\_MENOR}, \\
			& \tm{OP\_MAIOR}, && \tm{OP\_MENOR\_IGUAL}, && \tm{OP\_MAIOR\_IGUAL}, \\
			& \varepsilon
		\end{alignedat}
		\right\}
		\]
		
		\item[Conjunto de Regras de Produção ($P$)]: 
		O conjunto das regras de produção é definido por:
		
		\item[\nt{Programa}] $\rightarrow$ \nt{ListaDeComandos}
		\item[\nt{ListaDeComandos}] $\rightarrow$ \nt{Comando} $\mid$ \nt{Comando} \nt{ListaDeComandos}
		\item[\nt{Comando}] $\rightarrow$ \nt{Declaracao} $\mid$ \nt{Atribuicao} $\mid$ \nt{EstruturaDeControle} $\mid$ \nt{ChamadaDeFuncao} $\mid$ \nt{Bloco}
		\item[\nt{Declaracao}] $\rightarrow$ \nt{Tipo} \tm{IDENTIFICADOR} \nt{AtribuicaoOpcional} \tm{PONTO\_VIRGULA}
		\item[\nt{Atribuicao}] $\rightarrow$ \tm{IDENTIFICADOR} \tm{OP\_ATRIBUICAO} \nt{Expressao} \tm{PONTO\_VIRGULA}
		\item[\nt{AtribuicaoOpcional}] $\rightarrow$ \tm{OP\_ATRIBUICAO} \nt{Expressao} $\mid$ $\varepsilon$
		\item[\nt{Tipo}] $\rightarrow$ \tm{KEYWORD\_INT} $\mid$ \tm{KEYWORD\_FLOAT} $\mid$ \tm{KEYWORD\_STRING} $\mid$ \tm{KEYWORD\_BOOL}
		\item[\nt{Literais}] $\rightarrow$ \tm{INT} $\mid$ \tm{FLOAT} $\mid$ \tm{STRING} $\mid$ \tm{CHAR} $\mid$ \tm{BOOLEAN\_LITERAL}
		\item[\nt{Expressao}] $\rightarrow$ \nt{Termo} $\mid$ \nt{Expressao} \tm{OP\_SOMA} \nt{Termo} $\mid$ \nt{Expressao} \tm{OP\_SUB} \nt{Termo}
		\item[\nt{Termo}] $\rightarrow$ \nt{Fator} $\mid$ \nt{Termo} \tm{OP\_MULT} \nt{Fator} $\mid$ \nt{Termo} \tm{OP\_DIV} \nt{Fator}
		\item[\nt{Fator}] $\rightarrow$ \tm{IDENTIFICADOR} $\mid$ \nt{Literais} $\mid$ \tm{ABRE\_PARENTESES} \nt{Expressao} \tm{FECHA\_PARENTESES} $\mid$ \tm{OP\_INC} $\mid$ \tm{OP\_DEC}
		\item[\nt{EstruturaDeControle}] $\rightarrow$ \nt{If} $\mid$ \nt{For} $\mid$ \nt{While}
		\item[\nt{If}] $\rightarrow$ \tm{KEYWORD\_IF} \tm{ABRE\_PARENTESES} \nt{Condicao} \tm{FECHA\_PARENTESES} \nt{Comando} \nt{ElseOpcional}
		\item[\nt{ElseOpcional}] $\rightarrow$ \tm{KEYWORD\_ELSE} \nt{Comando} $\mid$ $\varepsilon$
		\item[\nt{Condicao}] $\rightarrow$ \nt{Expressao} \nt{OperadorRelacional} \nt{Expressao}
		\item[\nt{OperadorRelacional}] $\rightarrow$ \tm{OP\_IGUAL} $\mid$ \tm{OP\_DIFERENTE} $\mid$ \tm{OP\_MENOR} $\mid$ \tm{OP\_MAIOR} $\mid$ \tm{OP\_MENOR\_IGUAL} $\mid$ \tm{OP\_MAIOR\_IGUAL}
		\item[\nt{Bloco}] $\rightarrow$ \tm{ABRE\_CHAVES} \nt{ListaDeComandos} \tm{FECHA\_CHAVES}
		
		\item[Conjunto de Não-Terminais ($A$)] 
		O conjunto de símbolos não-terminais é definido por:
		\[
		A = \left\{
		\begin{alignedat}{3}
			& \nt{Programa}, && \nt{ListaDeComandos}, && \nt{Comando}, \\
			& \nt{Declaracao}, && \nt{Atribuicao}, && \nt{AtribuicaoOpcional}, \\
			& \nt{Tipo}, && \nt{Literais}, && \nt{Expressao}, \\
			& \nt{Termo}, && \nt{Fator}, && \nt{EstruturaDeControle}, \\
			& \nt{If}, && \nt{ElseOpcional}, && \nt{Condicao}, \\
			& \nt{OperadorRelacional}, \quad && \nt{Bloco}, && \nt{ChamadaDeFuncao}, \\
			& \nt{For}, && \nt{While}, && \nt{DoWhile}
		\end{alignedat}
		\right\}
		\]
		
		\item[Símbolo Inicial ($S$)] 
		O símbolo inicial da gramática é:
		\[
		S = \nt{Programa}
		\]
	\end{description}
	
	\section{Análise de Erros}
	\label{sec:err}
	
	O Simple C implementa um tratamento de erros em duas fases: léxica (Flex) e sintática (Bison).
	
	\subsection{Tratamento de Erros Léxicos (Flex)}
	O analisador léxico é configurado para detectar e reportar falhas específicas, além de caracteres desconhecidos, garantindo um diagnóstico preciso no código-fonte. Para isto, são utilizadas as variáveis globais \texttt{current\_line} e \texttt{current\_col}, que rastreiam a posição exata de cada token reconhecido.
	
	A função de erro léxico, \texttt{print\_error}, reporta a linha, coluna, o tipo de erro e o texto problemático (\texttt{yytext}). Erros capturados incluem:
	\begin{itemize}
		\item Identificadores que iniciam com dígitos.
		\item Literais de caracteres contendo múltiplos caracteres.
		\item Construtos não fechados, como comentários de bloco (\texttt{/*}) ou strings (\texttt{"\dots"}) no fim do arquivo ou com quebras de linha inesperadas.
	\end{itemize}
	
	\subsection{Tratamento de Erros Sintáticos (Bison)}
	
	A detecção de erros sintáticos é responsabilidade do Analisador Sintático (Bison). Um erro ocorre quando a sequência de tokens fornecida pelo Flex não pode ser reduzida a nenhuma regra de produção da Gramática Livre de Contexto ($G$).
	
	\subsubsection{Função de Erro Sintático e Rastreamento}
	Quando um erro de sintaxe é encontrado, o Bison invoca a função $\texttt{yyerror(\dots)}$. Esta função aproveita as variáveis globais $\texttt{current\_line}$ e $\texttt{current\_col}$ (mantidas pelo Flex) para informar ao usuário a linha e coluna exatas onde a violação sintática foi detectada.
	
	A função de erro, definida no arquivo Bison, é:
	\begin{lstlisting}[caption={Função para tratamento de erros}]
		void yyerror(const char *s) {
			fprintf(stderr,
			"Erro Sintatico na Linha %d, Coluna %d: %s\n",
			current_line,
			current_col,
			s
			);
			exit(1);
		}
	\end{lstlisting}
	
	
	\subsubsection{Precedência e Associatividade}
	A ambiguidade sintática, especialmente em expressões complexas, é resolvida pela definição explícita de Precedência e Associatividade dos operadores no arquivo Bison (usando diretivas como `left`, `right`). Isto garante que a estrutura sintática preferida siga a ordem de avaliação matemática e lógica esperada (ex: multiplicação antes da soma).
	\section{Gerenciamento de Estados}
	\label{sec:estados}
	Para melhor gerenciar o estado do analisador léxico, utilizamos a funcionalidade de estados do Flex. Em especial, foram criados 2 estados diferentes: \texttt{IN\_COMMENT} e \texttt{IN\_STRING}. 
	
	\subsection{Comentários}
	Os comentários podem aparecer de 2 formas no código: (i) comentários de linha única, que começam com \texttt{//} e se estendem até o final da linha; (ii) comentários de bloco, que começam com \texttt{/*} e terminam com \texttt{*/}.
	
	\subsection{Strings}
	
	As strings são sequências de caracteres delimitadas por aspas duplas (\texttt{\"}). O analisador léxico reconhece strings e trata caracteres de escape, como \texttt{\textbackslash n} para nova linha e \texttt{\textbackslash t} para tabulação.
	
	Para isso, foi-se utilizado a função \texttt{yymore()} do Flex, que permite concatenar a string lida em \texttt{yytext} com a próxima parte da string lida, até que o caractere de fechamento (\texttt{\"}) seja encontrado. 
	
	Com isso, é possível a declaração e atribuição de strings com múltiplas linhas. Segue no Código \ref{lsl:st}, exemplos diversos sobre este tipo de dado.
	
	\begin{lstlisting}[caption={Exemplos para o tratamento de strings.}, label={lsl:st}]
		// Teste de literais de string, incluindo escapes
		string s = "Uma string de teste com \"aspas\" escapadas.";
		string outra_string_123 = "outra string";
		string string_com_3_linhas = 
		"""
		Linha 1\nLinha 2\nLinha 3
		""";
	\end{lstlisting}
	
	\section{Exemplos de uso}
	Nesta seção serão descritos exemplos do código da Linguagem Simple C, visando introduzir conceitos básicos sobre a sintaxe para o uso da mesma. 
	
	\subsection{Declaração de Variáveis e Tipos de Dados}
	Abaixo é apresentado um trecho de código de exemplo da linguagem Simple C, que será processado pelo Analisador Léxico (Seção \ref{sec:token}). As cores indicam os tokens reconhecidos, conforme o estilo definido:
	
	\begin{lstlisting}[caption={Exemplo de Código com Tokens da Simple C}, label={lst:codigo_exemplo}]
		int i = 12345;
		int i_2 = -12345;
		float _f = .5; // Ponto flutuante implicito
		float _f2 = 0.555555;
		float _f3 = 1.000000;
		char c = 'A';
		bool flag = true;
		char newline = '\n'; // Teste de escape em char
		int resultado_final = 0;
	\end{lstlisting}
	
	\subsection{Estruturas Condicionais e de Controle}
	Seguem exemplos para estruturas condicionais e de controle. No Código \ref{lsl:if}, apresenta-se a utilização de um "If-Else". Já no Código \ref{lst:sw},  está definida a estrutura "Switch-Case".
	
	\begin{lstlisting}[caption={Exemplo de estrutura de Controle If-Else}, label={lsl:if}]
		
		// Estrutura condicional 'if-else' com operadores logicos 
		//e relacionais
		if (flag == true && (i < 1000 || i >= 2000)) {
			resultado_final = 1;
		} else if (!flag) {
			resultado_final = -1;
		}
	\end{lstlisting}
	
	\begin{lstlisting}[caption={Exemplo de estrutura de Controle Switch-Case}, label={lst:sw}]
		switch (c) {
			case 'A':
			i = 1;
			break;
			case 'B':
			i = 2;
			break;
			default:
			i = 0;
		}
	\end{lstlisting}
	
	\subsection{Laços de Repetição}
	\label{sec:lacos}
	
	A linguagem Simple C suporta três estruturas de repetição fundamentais, que permitem a execução iterativa de blocos de código: o laço \texttt{for}, o laço \texttt{while} e o laço \texttt{do-while}.
	O uso dos comandos \texttt{break} e \texttt{continue} (Tokens listados na Tabela \ref{tab:tokens}) é permitido dentro dos corpos de todos os laços para controlar o fluxo de execução.
	
	\subsubsection{Exemplo de Laço \texttt{for}}
	O laço \texttt{for} no Simple C segue a estrutura padrão, onde a inicialização, a condição de parada e o passo de iteração são explicitados entre parênteses.
	
	\begin{lstlisting}[caption={"Laço de repetição For Loop"}, label={lsl:fl}]
		for (int j = 0; j != 10; j++) {
			if (j <= 1) {
				continue; // Pula para a proxima iteracao
			}
			if (j > 8) {
				break; // Interrompe o laco
			}
		}
	\end{lstlisting}
	
	\subsubsection{Exemplo de Laços \texttt{while} e \texttt{do-while}}
	Os laços condicionais \texttt{while} e \texttt{do-while} são implementados com base na avaliação de uma expressão relacional. Note que o \texttt{do-while} garante pelo menos uma execução do bloco.
	
	\begin{lstlisting}[caption={"Laços de Repetição While e Do While"}, label={lsl:wl}]
		int k = 10;
		while(k > 5) {
			k--;
		}
		
		do {
			k++;
		} while (k < 10);
	\end{lstlisting}
	
	

\end{document}